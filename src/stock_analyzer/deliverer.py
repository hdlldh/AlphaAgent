"""
Insight delivery module for sending analysis results to users.

Supports multiple delivery channels, with Telegram as the primary implementation.
"""

import asyncio
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import List, Optional

from telegram import Bot
from telegram.error import TelegramError

from stock_analyzer.exceptions import DeliveryError
from stock_analyzer.models import DeliveryLog, Insight
from stock_analyzer.storage import Storage


@dataclass
class DeliveryResult:
    """Result of a delivery operation."""
    insight_id: int
    user_id: str
    channel: str
    status: str  # "success" or "failed"
    error_message: Optional[str] = None


@dataclass
class BatchDeliveryResult:
    """Result of batch delivery operation."""
    total: int
    success_count: int
    failure_count: int
    results: List[DeliveryResult]


class DeliveryChannel(ABC):
    """Abstract base class for delivery channels."""

    @abstractmethod
    async def send(self, user_id: str, message: str) -> bool:
        """
        Send message to user.

        Args:
            user_id: User identifier for this channel
            message: Message content to send

        Returns:
            True if successful, False otherwise

        Raises:
            DeliveryError: If delivery fails
        """
        pass

    @abstractmethod
    def format_insight(self, insight: Insight) -> str:
        """
        Format insight for this channel.

        Args:
            insight: Insight to format

        Returns:
            Formatted message string
        """
        pass


class TelegramChannel(DeliveryChannel):
    """Telegram delivery channel implementation."""

    def __init__(self, token: str, parse_mode: str = "Markdown"):
        """
        Initialize Telegram channel.

        Args:
            token: Telegram bot token
            parse_mode: Message parse mode (Markdown or HTML)
        """
        self.bot = Bot(token=token)
        self.parse_mode = parse_mode

    async def send(self, user_id: str, message: str) -> bool:
        """
        Send message via Telegram.

        Args:
            user_id: Telegram chat ID (can be username or numeric ID)
            message: Message to send

        Returns:
            True if successful

        Raises:
            DeliveryError: If sending fails
        """
        try:
            # Convert user_id to int if it's numeric, otherwise use as-is
            chat_id = int(user_id) if user_id.isdigit() or (user_id.startswith('-') and user_id[1:].isdigit()) else user_id

            await self.bot.send_message(
                chat_id=chat_id,
                text=message,
                parse_mode=self.parse_mode
            )
            return True

        except TelegramError as e:
            raise DeliveryError(
                user_id=user_id,
                reason=str(e),
                channel="telegram"
            )
        except Exception as e:
            raise DeliveryError(
                user_id=user_id,
                reason=f"Unexpected error: {str(e)}",
                channel="telegram"
            )

    def format_insight(self, insight: Insight) -> str:
        """
        Format insight for Telegram with Markdown.

        Args:
            insight: Insight to format

        Returns:
            Markdown-formatted message
        """
        # Build message parts
        header = f"ðŸ“Š *{insight.stock_symbol}* Stock Analysis"
        date_str = f"ðŸ“… {insight.analysis_date.strftime('%B %d, %Y')}"

        # Confidence indicator
        confidence_emoji = {
            "high": "ðŸŸ¢",
            "medium": "ðŸŸ¡",
            "low": "ðŸ”´"
        }
        confidence = f"{confidence_emoji.get(insight.confidence_level, 'âšª')} Confidence: {insight.confidence_level.upper()}"

        # Summary
        summary = f"*Summary:*\n{insight.summary}"

        # Trend analysis (if available)
        trend = ""
        if insight.trend_analysis:
            trend = f"\n\n*Trend Analysis:*\n{insight.trend_analysis}"

        # Risk factors
        risks = ""
        if insight.risk_factors:
            risks = "\n\n*âš ï¸ Risk Factors:*"
            for risk in insight.risk_factors:
                risks += f"\nâ€¢ {risk}"

        # Opportunities
        opportunities = ""
        if insight.opportunities:
            opportunities = "\n\n*ðŸ’¡ Opportunities:*"
            for opp in insight.opportunities:
                opportunities += f"\nâ€¢ {opp}"

        # Footer
        footer = f"\n\n_Analysis generated by AlphaAgent_"

        # Combine all parts
        message = f"{header}\n{date_str}\n{confidence}\n\n{summary}{trend}{risks}{opportunities}{footer}"

        # Telegram has a 4096 character limit
        if len(message) > 4096:
            message = message[:4093] + "..."

        return message


class InsightDeliverer:
    """Manages delivery of insights to users via multiple channels."""

    def __init__(
        self,
        storage: Storage,
        telegram_token: Optional[str] = None
    ):
        """
        Initialize deliverer.

        Args:
            storage: Storage instance for logging
            telegram_token: Telegram bot token (required for Telegram delivery)
        """
        self.storage = storage
        self.channels = {}

        # Initialize Telegram channel if token provided
        if telegram_token:
            self.channels["telegram"] = TelegramChannel(telegram_token)

    def add_channel(self, name: str, channel: DeliveryChannel):
        """
        Add a delivery channel.

        Args:
            name: Channel name (e.g., "telegram", "email")
            channel: Channel implementation
        """
        self.channels[name] = channel

    async def deliver_insight(
        self,
        insight: Insight,
        user_id: str,
        channel: str = "telegram"
    ) -> DeliveryResult:
        """
        Deliver insight to a single user.

        Args:
            insight: Insight to deliver
            user_id: User identifier
            channel: Delivery channel name

        Returns:
            DeliveryResult with status

        Raises:
            DeliveryError: If channel not found or delivery fails
        """
        if channel not in self.channels:
            raise DeliveryError(
                user_id=user_id,
                reason=f"Channel '{channel}' not configured",
                channel=channel
            )

        delivery_channel = self.channels[channel]

        try:
            # Format message
            message = delivery_channel.format_insight(insight)

            # Send message
            await delivery_channel.send(user_id, message)

            # Log successful delivery
            self._log_delivery(
                insight_id=insight.id,
                user_id=user_id,
                channel=channel,
                status="success"
            )

            return DeliveryResult(
                insight_id=insight.id,
                user_id=user_id,
                channel=channel,
                status="success"
            )

        except DeliveryError as e:
            # Log failed delivery
            self._log_delivery(
                insight_id=insight.id,
                user_id=user_id,
                channel=channel,
                status="failed",
                error_message=str(e)
            )

            return DeliveryResult(
                insight_id=insight.id,
                user_id=user_id,
                channel=channel,
                status="failed",
                error_message=str(e)
            )

    async def deliver_batch(
        self,
        insights: List[Insight],
        user_ids: List[str],
        channel: str = "telegram",
        parallel: int = 5
    ) -> BatchDeliveryResult:
        """
        Deliver multiple insights to multiple users.

        Args:
            insights: List of insights to deliver
            user_ids: List of user IDs to deliver to
            channel: Delivery channel name
            parallel: Number of parallel deliveries

        Returns:
            BatchDeliveryResult with summary and individual results
        """
        results = []

        # Create delivery tasks
        tasks = []
        for insight in insights:
            for user_id in user_ids:
                tasks.append((insight, user_id))

        # Execute deliveries with semaphore for rate limiting
        semaphore = asyncio.Semaphore(parallel)

        async def deliver_with_semaphore(insight: Insight, user_id: str):
            """Deliver insight with semaphore for parallel execution limit."""
            async with semaphore:
                try:
                    return await self.deliver_insight(insight, user_id, channel)
                except Exception as e:
                    # Return failed result even if exception occurs
                    return DeliveryResult(
                        insight_id=insight.id,
                        user_id=user_id,
                        channel=channel,
                        status="failed",
                        error_message=str(e)
                    )

        # Run all deliveries
        results = await asyncio.gather(
            *[deliver_with_semaphore(insight, user_id) for insight, user_id in tasks],
            return_exceptions=False
        )

        # Calculate summary
        success_count = sum(1 for r in results if r.status == "success")
        failure_count = sum(1 for r in results if r.status == "failed")

        return BatchDeliveryResult(
            total=len(results),
            success_count=success_count,
            failure_count=failure_count,
            results=results
        )

    def _log_delivery(
        self,
        insight_id: int,
        user_id: str,
        channel: str,
        status: str,
        error_message: Optional[str] = None
    ):
        """
        Log delivery to storage.

        Args:
            insight_id: Insight ID that was delivered
            user_id: User ID that received the delivery
            channel: Delivery channel used
            status: Delivery status ("success" or "failed")
            error_message: Error message if failed
        """
        log = DeliveryLog(
            insight_id=insight_id,
            user_id=user_id,
            delivery_method=channel,
            delivery_status=status,
            error_message=error_message,
            delivered_at=datetime.utcnow()
        )
        self.storage.save_delivery_log(log)

    async def deliver_to_subscribers(
        self,
        insight: Insight,
        channel: str = "telegram"
    ) -> BatchDeliveryResult:
        """
        Deliver insight to all users subscribed to its stock symbol.

        Args:
            insight: Insight to deliver
            channel: Delivery channel

        Returns:
            BatchDeliveryResult with delivery status for each subscriber
        """
        # Get subscriptions for this stock
        subscriptions = self.storage.get_subscriptions(
            stock_symbol=insight.stock_symbol,
            active_only=True
        )

        # Extract unique user IDs
        user_ids = list(set(sub.user_id for sub in subscriptions))

        if not user_ids:
            # No subscribers, return empty result
            return BatchDeliveryResult(
                total=0,
                success_count=0,
                failure_count=0,
                results=[]
            )

        # Deliver to all subscribers
        return await self.deliver_batch(
            insights=[insight],
            user_ids=user_ids,
            channel=channel,
            parallel=5
        )
